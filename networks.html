<!DOCTYPE html>

<html>
<head>
	<title></title>
	<meta charset="utf-8">
</head>
<body>

<style>

.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: black;
  fill: yellow;
  stroke-width: 1.5px;
  fill-opacity: 0.75;
  cursor: pointer;
}



text {
  font-family: sans-serif;
  font-size: 10px;
}

svg {
	border: 2px solid black;
	margin-top: 2%;
}


</style>
<h1>Season 1 without style</h1>
<select id="seasonSelect">
	<option value=1> Season 1</option>
	<option value=2> Season 2</option>
	<option value=3> Season 3</option>
	<option value=4> Season 4</option>
	<option value=5> Season 5</option>
	<option value=6> Season 6</option>
	<option value=7> Season 7</option>
	<option value=8> Season 8</option>
	<option value=9> Season 9</option>
	<option value=10> Season 10</option>
	<option value=11> Season 11</option>
	<option value=12> Season 12</option>
	<option value=13> Season 13</option>
	<option value=14> Season 14</option>
	<option value=15> Season 15</option>
	<option value=16> Season 16</option>
	<option value=17> Season 17</option>
	<option value=18> Season 18</option>
	<option value=19> Season 19</option>
	<option value=20> Season 20</option>
	<option value=21> Season 21</option>
	<option value=22> Season 22</option>
	<option value=23> Season 23</option>
	<option value=24> Season 24</option>
	<option value=25> Season 25</option>
	<option value=26> Season 26</option>
	<option value=27> Season 27</option>
	<option value=28> Season 28</option>
	<option value=29> Season 29</option>
	<option value=30> Season 30</option>
</select>
<br>
<svg width="960" height="600" class="svg_network"></svg>
<svg width="480" height="300" class="svg_network"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
window.addEventListener("load", function(){
	    
	season = 'season1.json';
	document.getElementById("seasonSelect").onchange = function(e) {
	    season = 'season'+this[this.selectedIndex].value+'.json';
	    console.log(season);
	};

	var svg = d3.select(".svg_network"),
	    width = +svg.attr("width"),
	    height = +svg.attr("height");

	var svg_graph = d3.select(".svg_graph").width = +svg.attr("width"),
	    height = +svg.attr("height");

	var color = d3.scaleOrdinal(d3.schemeCategory20);

	var simulation = d3.forceSimulation()
	    .force("link", d3.forceLink().id(function(d) { return d.id; }))
	    .force("charge", d3.forceManyBody().strength(-500))
	    .force("center", d3.forceCenter(width/2, height/2));

	d3.json(season, function(error, graph) {
	  if (error) throw error;

	  var link = svg.append("g")
	      .attr("class", "links")
	    .selectAll("line")
	    .data(graph.links)
	    .enter().append("line")
	      .attr("stroke-width", function(d) { return Math.sqrt(d.value*10); });

	  var node = svg.append("g")
	      .attr("class", "nodes")
	    .selectAll("g")
	    .data(graph.nodes)
	    .enter().append("g")

	  var circles = node.append("circle")
	      .attr("r", function(d){
	      	return d.weight*3;
	      })
	      .call(d3.drag()
	          .on("start", dragstarted)
	          .on("drag", dragged)
	          .on("end", dragended));

	  /*var lables = node.append("text")
	      .text(function(d) {
	        return d.id;
	      })
	      .attr('x', 0)
	      .attr('y', 6)
	      .attr('class', 'node_name')
	      .call(wrap, 20)*/

	  node.append("title")
	      .text(function(d) { return d.id + " - " + d.weight + " synopsis appearances"; });

	  simulation
	      .nodes(graph.nodes)
	      .on("tick", ticked);

	  simulation.force("link")
	      .links(graph.links);

	  function ticked() {
	    link
	        .attr("x1", function(d) { return d.source.x; })
	        .attr("y1", function(d) { return d.source.y; })
	        .attr("x2", function(d) { return d.target.x; })
	        .attr("y2", function(d) { return d.target.y; });

	    node
	        .attr("transform", function(d) {
	          return "translate(" + d.x + "," + d.y + ")";
	        })
	  }
	});

	function dragstarted(d) {
	  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
	  d.fx = d.x;
	  d.fy = d.y;
	}

	function dragged(d) {
	  d.fx = d3.event.x;
	  d.fy = d3.event.y;
	}

	function dragended(d) {
	  if (!d3.event.active) simulation.alphaTarget(0);
	  d.fx = null;
	  d.fy = null;
	}

	function wrap(text, width) {
	  text.each(function() {
	    var text = d3.select(this),
	        words = text.text().split(/\s+/).reverse(),
	        word,
	        line = [],
	        lineNumber = 0,
	        lineHeight = 1.1, // ems
	        y = text.attr("y"),
	        dy = parseFloat(text.attr("dy")),
	        tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
	    while (word = words.pop()) {
	      line.push(word);
	      tspan.text(line.join(" "));
	      if (tspan.node().getComputedTextLength() > width) {
	        line.pop();
	        tspan.text(line.join(" "));
	        line = [word];
	        tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
	      }
	    }
	  });
	}

	function type(d) {
	  d.value = +d.value;
	  return d;
	}

});

</script>
</body>
</html>